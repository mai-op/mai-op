#+TITLE: Заметки по контесту Math [5]
#+OPTIONS: toc:nil num:nil author:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../style.css" />
#+HTML_HEAD: <style>div.figure img {max-height:300px;max-width:900px;}</style>
#+HTML_HEAD_EXTRA: <style>.org-src-container {background-color: #303030; color: #e5e5e5;}</style>

Напишу о часто встречающихся ошибках в прошедшем контесте.

*** Переполнение типа

**** Где ошибка?
Давайте посмотрим на следующий код. Учитывая, что $n$ может быть равным $10^{16}$, попробуйте найти ошибку в нём. 
#+BEGIN_SRC c++
  int main(){
      long long n;
      cin >> n;
      vector<long long> p;
      vector<long long> a;
      for (int i = 2; i * i <= n; i++) {
          if (n % i != 0) 
              continue;
          p.push_back(i);
          a.push_back(0);
          while (n % i == 0) {
              a.back() += 1;
              n /= i;
          }
      }
      //...
  }
#+END_SRC

Ошибка в нём заключается в использовании типа $int$ для счётчика цикла $for$. Значение $i * i$ считается в типе $int$, и никогда не сможет стать больше $2^{31}-1$. Решением тут является использовать тип $long$ $long$.

**** И снова int
Попробуйте определить, в какой строчке здесь происходит переполнение интового типа. $|v[i]| < 10^{8}$, $1 \leq n \leq 5 \cdot 10^{5}$.  
#+BEGIN_SRC c++
  int main() {
      ios:: sync_with_stdio(false);
      int n;
      long long ans = 0;
      cin >> n;
      vector<int> v(n);
      for (int& x: v) cin >> x;
      sort(v.begin(), v.end());
      for (int i = 1; i * 2 <= n; i++)
          ans += (n - i * 2 + 1) * abs(v[i - 1] - v[n - i]);
      cout << ans << '\n';
      return 0;
  }
#+END_SRC

В строчке 10! Почему? Потому что оба множителя в произведении имеют тип $int$, так как в них все переменные типа $int$. 

*** Сложность алгоритма
Рассмотрим несколько примеров.

**** Сколько ждать?
Сначала самый простой. Здесь уже ошибка не только в использовании инта, но и в выборе алгоритма. Попробуйте оценить его сложность и прикинуть, сколько он будет работать для $n = 10^{16}$.
#+BEGIN_SRC c++
  int main() {
      int n;
      int sum = 0;
      cin >> n;
      for (int i = 1; i <= n; i++) {
          if (n % i == 0) {
              sum = sum + 1;
          }
      }
      cout << sum;
      return 0;
  }
#+END_SRC

Сложность, как не трудно догадаться, линейная, то есть $O(n)$. Это значит, что будет совершено порядка $n$ действий, для нашего случая $10^{16}$. Если предположить, что на кодфорсесе очень мощное железо, которое обрабатывает $10^{9}$ операций за секунду, то этот код будет работать $10^{7}$ секунд $\approx 116$ дней. То есть вывод ответа случится 17 февраля следующего года. Долго. 

Конечно, нужно использовать алгоритм со сложностью $O(\sqrt{n})$, заметив, что все делители разбиваются на пары $d$ и $\cfrac{n}{d}$. Останется ещё только обработать случай $d = \cfrac{n}{d}$.

**** Подождём?
Следующий код представляет хорошее начало для получения итогового решения задачи. Оцените его сложность, скажите, сколько он будет работать для $n = 5 \cdot 10^{5}$.

#+BEGIN_SRC c++
  for (int i = 0; i < n; i++){
      for (int j = i + 1; j < n; j++){
          ans += v[j] - v[i];
      }
   }
#+END_SRC

Не трудно заметить, что сложность вычисляется как сумма арифметической прогрессии $(n - 1) + (n - 2) + \ldots + 2 + 1 = \cfrac{n(n - 1)}{2}$. 

То есть сложность квадратичная, $O(n^2)$. Грубо оценим время работы для $n = 5 \cdot 10^{5}$: $n^2 = 25 \cdot 10^{10}$. С предположением о $10^{9}$ за секунду, получаем $250$ секунд работы. Но кодфорсес не ждёт.
  
*** Общие замечания по коду
Соблюдайте табуляцию в коде, делайте пробелы в строку между логически различными частями в коде. Объявляйте переменные рядом с теми местами, где они используются, что логично. Старайтесь называть переменные осмысленно.

Соблюдайте эти простые правила, и код будет писаться легче, ошибки искаться быстрее.

[[file:../index.org][На главную]]
